# 2. 알고리즘 설계화 분석의 기초

### 1. 기초 사항들

[바람직한 알고리즘]
1. 명확해야 함
2. 효율적이어야 함 (수행시간)

[알고리즘 분석의 필요성]
- 알고리즘의 타당성 확인
- 자원 사용 효율성 파악 (소요시간 / 메모리 / 통신대역 등)

[알고리즘의 수행 시간 분석]
- 어느 정도의 입력에 대해 어느 정도의 시간이 소요되는지 예측 가능
- 최악의 경우 분석, 평균적인 경우 분석 등
- " 입력의 크기에 대해 어떤 비율로 시간이 소요된다"로 표현
  ex) "n개의 자료를 정렬하는데 nlogn 에 비례한 시간 소요"

[재귀와 귀납적 사고]  
- 재귀 = 자기 호출(recurrence)
- 재귀적 구조 
  : 어떤 문제 안에 크기만 다를 뿐 성격이 똑같은 작은 문제(들)가 포함되어 있는 것
  ex) factorial, 수열의 점화식


### 2. 점근적 표기
[알고리즘의 점근적 분석]
- 크기가 작은 문제
  알고리즘의 효율성이 중요하지 않다.
  비효율적인 알고리즘도 무방하다.

- 크기가 충분히 큰 문제
  알고리즘의 효율성이 중요하다.
  비효율적인 알고리즘은 치명적이다.

- 입력의 크기가 충분히 큰 경우에 대한 분석 : 점근적 분석 (asymptotic analysis)
  
  대표적인 점근적 표기법 : Θ-표기법 / Ο-표기법 / Ω-표기법

  #### Θ-표기법 
  - Θ(f(n))
    점근적 증가율이 f(n)과 일치하는 모든 함수의 집합
    ex) 알고리즘의 소요 시간이 Θ(n) 라면 대략 n에 비례한 시간이 소요

    g(n) ∈ Θ(f(n)) ⇒ g 는 f 와 같은 비율로 증가


  #### O-표기법
  - O(f(n))
    점근적 증가율이 f(n)이하인 모든 함수의 집합
    g(n) ∈ O(f(n)) ⇒ g 는 f 보다 빠르게 증가하지 않는다.

    즉 O(f(n)) = g(n) 을 확인하고자 할 때,
    f(n)보다 g(n)이 작거나 같으면 맞다. 

    알 수 있는 한 최대한 tight 하게! -> Tight하지 않은 만큼 정보의 손실 발생


  #### Ω-표기법
  - Ω(f(n))
    점근적 증가율이 f(n)이상인 모든 함수의 집합
    O(f(n)) 과 대칭적
    g(n) ∈ Ω(f(n)) ⇒ g 는 f 보다 느리게 증가하지 않는다.

    즉 Ω(f(n)) = g(n) 을 확인하고자 할 때,
    f(n)보다 g(n)이 크거나 같으면 맞다.


  [점근적 표기법의 관계]
  Θ(f(n)) = O(f(n)) ∩ Ω(f(n))
  


### 3. 점근적 표기의 엄밀한 정의

#### [5가지 점근적 표기법]  
- Ο-표기법 (빅-오, 오) 
- Ω-표기법 (빅-오메가, 오메가) 
- Θ-표기법 (쎄타)
- ο-표기법 (리틀-오)
- ω-표기법 (리틀-오메가)

#### O-표기법
- O(f(n)) = { g(n) | 충분히 큰 모든 n에 대하여 g(n) ≤ cf(n) 인 양의 상수 c가 존재한다 }

#### Ω-표기법
- Ω(f(n)) = { g(n) | 충분히 큰 모든 n에 대하여 g(n) ≥ cf(n) 인 양의 상수 c가 존재한다 }


#### Θ-표기법


#### ο-표기법
- g(n) = o(f(n)) ⇒ g 는 f 보다 느리게 증가한다

#### ω-표기법
- g(n) = 𝜔(f(n)) ⇒ g 는 f 보다 빠르게 증가한다.